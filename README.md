# Algorytmy i Struktury Danych

## Spis Treści

### Algorytmy Sortujące

[Złożoności Algorytmów Sortujących](#złożoności-algorytmów-sortujących)

- [Bogo Sort](https://github.com/tukarp/Algorithms-And-Data-Structures/blob/main/Sorting%20Algorithms/Bogo%20Sort.cpp)
- [Bubble Sort](https://github.com/tukarp/Algorithms-And-Data-Structures/blob/main/Sorting%20Algorithms/Bubble%20Sort.cpp)
- [Bucket Sort](https://github.com/tukarp/Algorithms-And-Data-Structures/blob/main/Sorting%20Algorithms/Bucket%20Sort.cpp)
- [Cocktail Sort](https://github.com/tukarp/Algorithms-And-Data-Structures/blob/main/Sorting%20Algorithms/Cocktail%20Sort.cpp)
- [Counting Sort](https://github.com/tukarp/Algorithms-And-Data-Structures/blob/main/Sorting%20Algorithms/Counting%20Sort.cpp)
- [Heap Sort](https://github.com/tukarp/Algorithms-And-Data-Structures/blob/main/Sorting%20Algorithms/Heap%20Sort.cpp)
- [Insertion Sort](https://github.com/tukarp/Algorithms-And-Data-Structures/blob/main/Sorting%20Algorithms/Insertion%20Sort.cpp)
- [Merge Sort](https://github.com/tukarp/Algorithms-And-Data-Structures/blob/main/Sorting%20Algorithms/Merge%20Sort.cpp)
- [Quick Sort](https://github.com/tukarp/Algorithms-And-Data-Structures/blob/main/Sorting%20Algorithms/Quick%20Sort.cpp)
- [Radix Sort](https://github.com/tukarp/Algorithms-And-Data-Structures/blob/main/Sorting%20Algorithms/Radix%20Sort.cpp)
- [Selection Sort](https://github.com/tukarp/Algorithms-And-Data-Structures/blob/main/Sorting%20Algorithms/Selection%20Sort.cpp)
- [Shell Sort](https://github.com/tukarp/Algorithms-And-Data-Structures/blob/main/Sorting%20Algorithms/Shell%20Sort.cpp)

### Struktury danych

[Złożoności Operacji na Strukturach Danych](#złożoności-operacji-na-strukturach-danych)

- [Array](https://github.com/tukarp/Algorithms-And-Data-Structures/blob/main/Data%20Structures/Array.cpp)
- [Binary Tree](https://github.com/tukarp/Algorithms-And-Data-Structures/blob/main/Data%20Structures/Binary%20Tree.cpp)
- [Circullar Linked List](https://github.com/tukarp/Algorithms-And-Data-Structures/blob/main/Data%20Structures/Circular%20Linked%20List.cpp)
- [Graph](https://github.com/tukarp/Algorithms-And-Data-Structures/blob/main/Data%20Structures/Graph.cpp)
- [List](https://github.com/tukarp/Algorithms-And-Data-Structures/blob/main/Data%20Structures/List.cpp)
- [Queue (klasyczna tablicowa)](https://github.com/tukarp/Algorithms-And-Data-Structures/blob/main/Data%20Structures/Queue%20(klasyczna%20tablicowa).cpp)
- [Queue (tablicowa z zawijaniem)](https://github.com/tukarp/Algorithms-And-Data-Structures/blob/main/Data%20Structures/Queue%20(tablicowa%20z%20zawijaniem).cpp)
- [Stack](https://github.com/tukarp/Algorithms-And-Data-Structures/blob/main/Data%20Structures/Stack.cpp)

### Treści zadań

- [Zadanie 1 - Wyremontujemy wasz dom!](#zadanie-1---wyremontujemy-wasz-dom)
- [Zadanie 2 - Szczyty](#zadanie-2---szczyty)
- [Zadanie 3 - Fala](#zadanie-3---fala)
- [Zadanie 4 - Faktury](#zadanie-4---faktury)
- [Zadanie 5 - Dostawca mleka](#zadanie-5---dostawca-mleka)
- [Zadanie 6 - Turniej](#zadanie-6---turniej)
- [Zadanie 7 - Premia lub hańba](#zadanie-7---premia-lub-hańba)
- [Zadanie 8 - Polowanie na kraby](#zadanie-8---polowanie-na-kraby)
- [Zadanie 9 - Rankingowe polowanie](#zadanie-9---rankingowe-polowanie)

### Rozwiązania

- [Zadanie 1 - Wyremontujemy wasz dom!](https://github.com/tukarp/Algorithms-And-Data-Structures/blob/main/Algorithms%20And%20Data%20Structures%20I/Zadanie%201%20-%20Wyremontujemy%20wasz%20dom!.cpp)
- [Zadanie 2 - Szczyty](https://github.com/tukarp/Algorithms-And-Data-Structures/blob/main/Algorithms%20And%20Data%20Structures%20I/Zadanie%202%20-%20Szczyty.cpp)
- [Zadanie 3 - Fala](https://github.com/tukarp/Algorithms-And-Data-Structures/blob/main/Algorithms%20And%20Data%20Structures%20I/Zadanie%203%20-%20Fala.cpp)
- [Zadanie 4 - Faktury](https://github.com/tukarp/Algorithms-And-Data-Structures/blob/main/Algorithms%20And%20Data%20Structures%20I/Zadanie%204%20-%20Faktury.cpp)
- [Zadanie 5 - Dostawca mleka](https://github.com/tukarp/Algorithms-And-Data-Structures/blob/main/Algorithms%20And%20Data%20Structures%20I/Zadanie%205%20-%20Dostawca%20mleka.cpp)
- [Zadanie 6 - Turniej](https://github.com/tukarp/Algorithms-And-Data-Structures/blob/main/Algorithms%20And%20Data%20Structures%20I/Zadanie%206%20-%20Turniej.cpp)
- [Zadanie 7 - Premia lub hańba](https://github.com/tukarp/Algorithms-And-Data-Structures/blob/main/Algorithms%20And%20Data%20Structures%20I/Zadanie%207%20-%20Premia%20lub%20hanba.cpp)
- [Zadanie 8 - Polowanie na kraby](https://github.com/tukarp/Algorithms-And-Data-Structures/blob/main/Algorithms%20And%20Data%20Structures%20I/Zadanie%208%20-%20Polowanie%20na%20kraby.cpp)
- [Zadanie 9 - Rankingowe polowanie](https://github.com/tukarp/Algorithms-And-Data-Structures/blob/main/Algorithms%20And%20Data%20Structures%20I/Zadanie%209%20-%20Rankingowe%20polowanie.cpp)

### Złożoności Algorytmów Sortujących

|    Algorytm    |  Złożoność Czasowa Optymistyczna  |  Złożoność Czasowa Średnia  |   Złożoność Czasowa Pesymistyczna  |  Złożoność Pamięciowa Pesymistyczna  |
|  :----------   |            :----------:           |        :----------:         |            :----------:            |             :----------:             |
| Selection Sort | O($n^{2}$)                        | O($n^{2}$)                  | O($n^{2}$)                         | O($n$)                               |
| Bubble Sort    | O($n$)                            | O($n^{2}$)                  | O($n^{2}$)                         | O($n$)                               |
| Insertion Sort | O($n$)                            | O($n^{2}$)                  | O($n^{2}$)                         | O($n$)                               |
| Heap Sort      | O($n{log(n)}$)                    | O($n{log(n)}$)              | O($n{log(n)}$)                     | O($n$)                               |
| Merge Sort     | O($n{log(n)}$)                    | O($n{log(n)}$)              | O($n{log(n)}$)                     | O($n$)                               |
| Quick Sort     | O($n{log(n)}$)                    | O($n{log(n)}$)              | O($n^{2}$)                         | O($n$)                               |
| Bucket Sort    | O($n+k$)                          | O($n+k$)                    | O($n^{2}$)                         | O($n$)                               |
| Radix Sort     | O($nk$)                           | O($nk$)                     | O($nk$)                            | O($n+k$)                             |
| Counting Sort  | O($n+k$)                          | O($n+k$)                    | O($n+k$)                           | O($k$)                               |
| Shell Sort     | O($n{log(n)}$)                    | O($n{log(n)}$)              | O($n^{2}$)                         | O($1$)                               |

Źródło: https://www.geeksforgeeks.org/time-complexities-of-all-sorting-algorithms/

### Złożoności Operacji na Strukturach Danych

| Struktura Danych   | Złożoność Czasowa Średnia |     |     |     | Złożoność Czasowa Pesymistyczna |     |     |     | Złożoność Pamięciowa |
| :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: |
|                    | Dostęp        | Przeszukiwanie | Wstawianie    | Usuwanie      | Dostęp        | Przeszukiwanie | Wstawianie    | Usuwanie     | Pesymistyczna |
| Array              | O($1$)        | O($n$)         | O($n$)        | O($n$)        | O($1$)        | O($n$)         | O($n$)        | O($n$)        | O($n$) |
| Stack              | O($n$)        | O($n$)         | O($1$)        | O($1$)        | O($n$)        | O($n$)         | ($1$)         | ($1$)         | O($n$) |
| Queue              | O($n$)        | O($n$)         | O($1$)        | O($1$)        | O($n$)        | O($n$)         | O($1$)        | O($1$)        | O($n$) |
| Singly-Linked List | O($n$)        | O($n$)         | O($1$)        | O($1$)        | O($n$)        | O($n$)         | O($1$)        | O($1$)        | O($n$) |
| Doubly-Linked List | O($n$)        | O($n$)         | O($1$)        | O($1$)        | O($n$)        | O($n$)         | O($1$)        | O($1$)        | O($n$) |
| Skip List          | O(${log(n)}$) | O(${log(n)}$)  | O(${log(n)}$) | O(${log(n)}$) | O($n$)        | O($n$)         | O($n$)        | O($n$)      | O($n{log(n)}$) |
| Hash Table         | N/A           | O($1$)         | O($1$)        | O($1$)        | N/A           | O($n$)         | O($n$)        | O($n$)        | O($n$) |
| Binary Search Tree | O(${log(n)}$) | O(${log(n)}$)  | O(${log(n)}$) | O(${log(n)}$) | O($n$)        | O($n$)         | O($n$)        | O($n$)        | O($n$) |
| Cartesian Tree     | N/A           | O(${log(n)}$)  | O(${log(n)}$) | O(${log(n)}$) | N/A           | O($n$)         | O($n$)        | O($n$)        | O($n$) |
| B-Tree             | O(${log(n)}$) | O(${log(n)}$)  | O(${log(n)}$) | O(${log(n)}$) | O(${log(n)}$) | O(${log(n)}$)  | O(${log(n)}$) | O(${log(n)}$) | O($n$) |
| Red-Black Tree     | O(${log(n)}$) | O(${log(n)}$)  | O(${log(n)}$) | O(${log(n)}$) | O(${log(n)}$) | O(${log(n)}$)  | O(${log(n)}$) | O(${log(n)}$) | O($n$) |
| Splay Tree         | N/A           | O(${log(n)}$)  | O(${log(n)}$) | O(${log(n)}$) | N/A           | O(${log(n)}$)  | O(${log(n)}$) | O(${log(n)}$) | O($n$) |
| AVL Tree           | O(${log(n)}$) | O(${log(n)}$)  | O(${log(n)}$) | O(${log(n)}$) | O(${log(n)}$) | O(${log(n)}$)  | O(${log(n)}$) | O(${log(n)}$) | O($n$) |
| KD Tree            | O(${log(n)}$) | O(${log(n)}$)  | O(${log(n)}$) | O(${log(n)}$) | O($n$)        | O($n$)         | O($n$)        | O($n$)        | O($n$) |

Źródło: https://www.bigocheatsheet.com/

## Zadanie 1 - Wyremontujemy wasz dom!

### Treść zadania

Gdzieś na Pacyfiku pośrodku kompletnie niczego znajduje się Wyspa. Zamieszkuje ją nieco prymitywne plemię Dotnetu. Mieszkańcy postanowili nauczyć się sądzić marchew. Ale ponieważ nie umieli, potrzebowali tutoriali z Internetu. Musieli też zamówić nasionka i nawozy ze sklepu w Europie. Ale zarówno Youtube, jak i zakupy w sieci były dla nich nieosiągalne. Nie mieli ani komputerów, ani smartfonów, ani połączenia ze światłowodem. Właściwie to nie mieli też prądu, a najbliższy sklep był 3000 km dalej. Postanowili więc się zmodernizować i przeprowadzić cyfryzację na całej Wyspie. Sołtys Wyspy sprowadził w tym celu ekipę IT, na której czele stanęli programiści Ada i Serweryn.

Ci po przybyciu zdecydowali, że rozpoczną od wyłonienia spośród członków poszczególnych wiosek łączników. Zlecaliby im pomniejsze zadania, które wymagałyby częstych kontaktów z nieznaną im jeszcze społecznością. Wybór miał paść na osobę najlepszą według wybranego przez nich kryterium. Poprosili zatem Sołtysa o listę wszystkich mieszkańców z poszczególnych wiosek z informacjami na ich temat. Każdy mieszkaniec miał być opisany przez:

- 1 - liczbę posiadanych umiejętności,
- 2 - wzrost w centymetrach,
- 3 - średnią szybkość wyrażoną w liczbie wykonanych czynności na godzinę.

Następnie opierając się o dane z list chcieli wybrać osobę najbardziej uzdolnioną (1 - ma najwięcej umiejętności) lub najwyższą (2 - z najwyższym wzrostem) lub najszybszą (3 - wykonuje najwięcej czynności w ciągu godziny). Zdarzałoby się czasem, że w danej wiosce jest kilka osób z najwyższą wartością wymaganego kryterium. W takiej sytuacji spośród nich wybiera się osobę według kolejnego wybranego kryterium. Jeśli wciąż jest więcej osób spełniających dwa kryteria, wybiera się spośród nich osobę według trzeciego kryterium. Przykładowo dla wybranej kolejności kryterium 2 3 1 najpierw szuka się osób najwyższych (2), następnie najszybszych (3), a na końcu najzdolniejszych (1).

### Wejście:

W pierwszej linii wejścia znajduje się liczba całkowita ***n***, oznaczająca liczbę wiosek. Dalej znajduje się ***n*** zestawów danych. Każdy zestaw składa się z liczby całkowitej ***m*** , oznaczającej liczbę mieszkańców wioski oraz trzech liczb 1, 2 i 3 oddzielonych spacjami w dowolnej kolejności. Decydują one o kolejności kryteriów, według których wybierani będą mieszkańcy wioski. W kolejnych ***m*** liniach są wiersze opisujące mieszkańców. Na opis mieszkańca składa się jednowyrazowy napis ***s*** , liczba naturalna ***u*** , liczba rzeczywista ***w*** i liczba naturalna ***c*** , które oznaczają odpowiednio imię mieszkańca, liczbę jego umiejętności, wzrost w centymetrach i średnia szybkość wyrażona w czynnościach na godzinę.

**1 ≤ n ≤ 10**

**1 ≤ m ≤ 2000000**

### Wyjście:

Na wyjściu dla każdej wioski program powinien wypisać imię tego mieszkańca, który spełnia założone kryteria. W przypadku dwóch osób z tymi samymi wartościami dla wszystkich kryteriów należy zachować kolejność wystąpienia na liście.

### Przykład:

Wejście:

```
3
5
2 3 1
Abidemi 3 160.5 12 
Bayo 3 172.4 12 
Chika 2 190.2 2 
Dalili 3 167.9 12 
Esi 1 190.2 3 
5
3 1 2
Abidemi 3 160.5 12 
Bayo 3 172.4 12 
Chika 2 190.2 3 
Dalili 3 167.9 12 
Esi 1 190.2 2 
5
1 2 3
Abidemi 3 167.9 12 
Bayo 3 167.9 12 
Chika 2 190.2 3 
Dalili 3 167.9 12 
Esi 1 190.2 2 
```

Wyjście:

```
Esi 
Bayo 
Abidemi
```

### [Rozwiązanie](https://github.com/tukarp/Algorithms-And-Data-Structures/blob/main/Algorithms%20And%20Data%20Structures%20I/Zadanie%201%20-%20Wyremontujemy%20wasz%20dom!.cpp)

## Zadanie 2 - Szczyty

### Treść Zadania

Ada i Serweryn w ramach dalszego modernizowania Wyspy chcieli zbudować wieże transmisyjne i idealnie nadawały się do tego najwyższe szczyty w okolicy. Najoszczędniejszy sposób rozmieszczenia wież polegał na tym, by prace rozpocząć na najniższym wybranym szczycie, stopniowo przenosząc się coraz wyżej, aż do najwyższego szczytu.

Wyspa była bardzo górzystym terenem. Wszystkie szczyty tam miały swoją nazwę. Członkowie plemienia mieli szczególny szacunek do szczytów, których wysokość nad poziomem morza była potęgą dwójki. Ada i Serweryn postanowili uszanować ich upodobanie i szczyty o takich wysokościach obsłużyć w pierwszej kolejności.

### Wejście:

W pierwszej linii wejścia znajduje się liczba całkowita ***t***, oznaczająca liczbę testów. Dalej znajduje się ***t*** zestawów danych. Każdy zestaw składa się z liczby całkowitej ***n***, oznaczającej liczbę szczytów. W kolejnych ***n*** liniach są wiersze opisujące szczyty. Opis składa się z jednowyrazowego napisu ***s*** - nazwy szczytu oraz liczby dodatniej całkowitej ***w*** - wysokości tego szczytu w metrach nad poziomem morza.

***1 ≤ t ≤ 10***

***1 ≤ n ≤ 50000***

***1 ≤ w < 2^32***

### Wyjście:

Na wyjściu dla każdego zestawu danych program powinien wypisać uporządkowaną listę szczytów w kolejności stawiania wież. Każdy szczyt ma zostać wyświetlony w formacie s-w. W przypadku szczytów z tymi samymi wartościami należy zachować kolejność wystąpienia na liście.

### Przykład:

Wejście:

```
3
5
Indrys 3
Fossa 67
Dingo 64
Werweta 10
Kwezal 1
3
Indrys 3
Fossa 2
Dingo 4
1
Indrys 10
```

Wyjście:

```
Kwezal-1 Dingo-64 Indrys-3 Werweta-10 Fossa-67
Fossa-2 Dingo-4 Indrys-3
Indrys-10 
```

***Uwaga! Nie można używać bibliotek STL. Program ma być samodzielną implementacją algorytmu sortującego.***

### [Rozwiązanie](https://github.com/tukarp/Algorithms-And-Data-Structures/blob/main/Algorithms%20And%20Data%20Structures%20I/Zadanie%202%20-%20Szczyty.cpp)

## Zadanie 3 - Fala

### Treść Zadania

Dzieci na Wyspie bardzo lubiły zagadywać pracowników Ady i Serweryna, wypytując o sposoby spędzania wolnego czasu w ich stronach. Ostatnio na przykład zapoznały się z kulturą kibiców piłkarskich (w ekipie znalazł się fan Motoru Lublin) i tym, że podczas meczy na trybunie robi się falę meksykańską. Fala wydała im się tak interesująca, że dzieci spróbowały ją odtworzyć, gdy stały w kółeczku. Pierwsza osoba unosiła ręce do góry, po niej kolejna i tak dalej. Ale przez brak piłkarskich emocji i stosunkowo małą liczbę uczestników po kilku okrążeniach fali znudziło im się to. Postanowiły zmienić trochę zasady i stworzyć grę bazującą na meksykańskiej fali.

Dzieci dobrały się w pary i stanęły w okręgu. Następnie osoba z pary stojąca z lewej strony zamieniała się miejscami z osobą z lewej strony z sąsiedniej pary (pomiędzy daną parą znajduje się prawa osoba z pary z lewej strony i lewa osoba z pary z prawej strony). Później jeden z graczy zaczynał falę unosząc ręce w górę, sąsiadująca osoba to powtarzała i tak dalej. Jeżeli któryś z uczestników pomylił się (podniósł ręce za wcześnie, za późno, nie w swojej kolejce lub zapomniał) - odpadał z gry (w grze mogła wciąż być druga osoba z pary). Gra wtedy toczy się dalej rozpoczynając od osoby, która jako ostatnia wykonała poprawny ruch, ale ze zmienionym kierunkiem.

Gracz, który właśnie podniósł ręce mógł zainicjować falę powracającą, to znaczy zmieniał kierunek gry przez wydanie komendy i ponowne podniesienie rąk. Zwyciężała ta para, która najdłużej utrzymywała się w grze. Para wygrywała też wtedy, gdy tylko jedna z osób pozostawała w grze.

Ta ulepszona wersja meksykańskiej fali tak bardzo się dzieciom spodobała, że te z nich, które odpadały wcześniej chciały czym prędzej wrócić do gry. Uczestnicy zgodzili się, że gra sama w sobie jest ważniejsza niż wygrana, więc czasami po pomyłce któregoś gracza pozwalano wracać do okręgu parom, które odpadały wcześniej. Powracająca para stawała w taki sposób, by pomiędzy nią znalazły się dwie osoby, obok których znajdował się właśnie odchodzący gracz.

Dla przykładu:
- Początkowe ustawienie 3 osób obok siebie: P1 P2 P3
- Po pomyłce osoby P2: P1 P3
- Po przyłączeniu nowej pary: Pn P1 P3 Pn

Grupa Ady i Serweryna obserwując poczynania dzieci postanowiła zasymulować ich rozgrywkę.

### Wejście:

Na wejściu podane są liczby naturalne ***n***, ***p***, ***k***, oznaczające liczbę par, numer pary rozpoczynającej rozgrywkę (pary numerowane są od ***0***, grę rozpoczyna osoba z prawej) oraz początkowy zwrot gry, gdzie ***0*** - zgodnie z ruchem wskazówek zegara, ***1*** - odwrotnie do ruchu wskazówek zegara. Zakładamy, że na starcie pary stoją numerami rosnąco właśnie zgodnie z ruchem wskazówek zegara.
W kolejnym wierszu znajduje się liczba naturalna ***m***, wyznaczająca liczbę operacji, w następnych ***m*** wierszach znajdą się deskrytptory operacji ***op***, parametr ***x*** i w szczególnym przypadku ***flaga*** (czyli w wierszu mogą znaleźć się dwie lub trzy liczby naturalne). Operacje są zdefiniowane następująco:

- ***0 x - wykonanie x ruchów*** w grze (jeden ruch to uniesienie rąk przez jedną osobę) i wyświetlenie aktualnego stanu gry poczynając od osoby w parze, na której po x ruchach zatrzymała się runda zgodnie z aktualnym zwrotem ruchu.
- ***1 x flaga - pomyłka osoby i ewentualny powrót wyeliminowanej pary***; odejście osoby, na której zatrzyma się runda po ***x*** ruchach; dla flagi: ***1*** - do rozgrywki wraca para, której najdłużej nie było w grze, ***0*** - nic się nie dzieje, o ile po odejściu gracza w kółku zostały więcej niż 3 osoby, w przeciwnym wypadku do rozgrywki wraca para, której najdłużej nie było w grze.
- ***2 x - zmiana kierunku ruchu***; po ***x*** ruchach ***x-ta*** w kolejności osoba wykonuje dodatkowy ruch oznaczający zmianę kierunku i kolejne uniesienia odliczane są w przeciwną stronę (dodatkowe uniesienie rąk liczone jest jako pierwszy ruch po zmianie kierunku).

***3 ≤ n ≤ 10000***

***k = {0, 1}***

***1 ≤ m ≤ 10000***

***op = {0, 1, 2}***

### Wyjście:

Na wyjściu program wypisuje efekty operacji wyświetlania aktualnego stanu gry.

### Przykład:

Wejście:

```
5 4 1
6
2 6
2 3
1 7 0
0 2
1 3 0
0 5
```

Wyjście:

```
4 1 0 2 1 3 2 4 0
2 3 1 2 1 4 0 4
```

***Uwaga! Zadanie ma być samodzielną implementacją list bez wykorzystania bibliotek STL.***

### [Rozwiązanie](https://github.com/tukarp/Algorithms-And-Data-Structures/blob/main/Algorithms%20And%20Data%20Structures%20I/Zadanie%203%20-%20Fala.cpp)

## Zadanie 4 - Faktury

### Treść Zadania

Biuro administracji Sołtysa nie było przyzwyczajone do pracy z dużą liczbą faktur. A zamówienia do budowy infrastruktury na Wyspie wciąż napływały. Dodatkowo Sołtys zatrudnił ostatnio bratanka z sąsiedniej wioski, a ten niezbyt dobrze radził sobie z drukarką. Wiele faktur wydrukował po kilka lub kilkanaście razy. Teraz całe biuro jest nimi wypełnione. Sołtys zwrócił się o pomoc do Ady i Serweryna. Poprosił ich o jakieś narzędzie do uporządkowania wszystkich faktur alfabetycznie. Ada i Serweryn wpadli na pomysł, by użyć do tego binarnej struktury drzewiastej. Wymyślili też, że nie trzeba wprowadzać kilka razy tej samej faktury omyłkowo drukowanej przez bratanka Sołtysa. Wystarczy zapamiętać w takim drzewie liczbę wystąpień każdej z faktur.

### Wejście:

Na standardowym wejściu w pierwszej linii pojawia się liczba wydrukowanych faktur do wprowadzenia ***n***, a następnie ***n*** linii zawierających nazwy faktur. Nazwy mogą składać się z cyfr i wielkich liter.

***0 ≤ n ≤ 3000000***

### Wyjście:

Należy wypisać w kolejnych liniach listę ***n*** wprowadzonych faktur posortowaną rosnąco.

### Przykład:

Wejście:

```
10
AAAAAAA1234
BC21374A12
POAB0986541
XZASQ4689
POAB0986541
SWE1243D23
POAB0986541
DER098765532
VV111111111
VV111111111
```

Wyjście:

```
AAAAAAA1234
BC21374A12
DER098765532
POAB0986541
POAB0986541
POAB0986541
SWE1243D23
VV111111111
VV111111111
XZASQ4689
```

***Uwaga! Zadanie ma być samodzielną implementacją drzewa binarnego bez wkorzystania bibliotek STL.***

### [Rozwiązanie](https://github.com/tukarp/Algorithms-And-Data-Structures/blob/main/Algorithms%20And%20Data%20Structures%20I/Zadanie%204%20-%20Faktury.cpp)

## Zadanie 5 - Dostawca mleka

### Treść Zadania

Dostawca mleka Kazimierz postanowił pójść z duchem czasu i wysłać swojego wiernego konia na emeryturę, zaś wóz przerobić na huśtawkę. By jednak nadal mógł dostarczać mleko potrzebował nowego środka transportu. Zgodził mu się pomóc znany na Wyspie szaman i wynalazca: Leonard. Panowie wspólnymi siłami zaprojektowali samochód dla Kazimierza, jednak nie byli w stanie ustalić potrzebnej wielkości pojemnika na mleko. Udali się po pomoc do Ady i Serweryna. Kazimierz nie odwiedzał wszystkich wiosek na wyspie, a jedynie pewien ich podzbiór. Informatycy zdecydowali więc, że ustalą liczbę wiosek mijanych przez Kazimierza po drodze do najdalszego z jego celów. Na tej podstawie Leonard będzie w stanie wyliczyć objętość pojemnika na mleko w samochodzie Kazimierza.

### Wejście:

W pierwszej linii wejścia znajduje się liczba naturalna ***n***, oznaczająca liczbę wszystkich wiosek. Kolejną linię stanowi liczba naturalna ***m***, która określa liczbę wiosek odwiedzanych przez Kazimierza.

Następnie pojawia się linia zawierająca nazwy wszystkich wiosek oddzielone spacjami. Nazwy mogą składać się z liter i cyfr. W następnej linii podane są listy sąsiadów wszystkich ***n*** wiosek, zakończone pojedynczymi literami "X". Kolejność list sąsiadów jest zgodna z kolejnością wprowadzania nazw wiosek, tzn. ***i***-ty ciąg zakończony literą "X" określa sąsiadów ***i***-tej wioski z ciągu nazw wiosek.

Dwie ostatnie linie wejścia to, kolejno, nazwa wioski początkowej oraz lista ***m*** nazw wiosek docelowych Kazimierza, oddzielonych spacjami. Do każdej z wiosek docelowych można dotrzeć z wioski startowej.

***1 ≤ n ≤ 30000***

***1 ≤ m ≤ 100***

### Wyjście:

Liczba wiosek odwiedzanych podczas podróży do najodleglejszej wioski docelowej.

### Przykład:

Wejście:

```
5
2
Antonin Bulgur Czychawa Drecja Euk
Bulgur Euk X Antonin Czychawa Drecja X Bulgur Drecja X Bulgur Czychawa Euk X Antonin Drecja X
Antonin
Bulgur Drecja
```

Wyjście:

```
2
```

### [Rozwiązanie](https://github.com/tukarp/Algorithms-And-Data-Structures/blob/main/Algorithms%20And%20Data%20Structures%20I/Zadanie%205%20-%20Dostawca%20mleka.cpp)

## Zadanie 6 - Turniej

### Treść Zadania

Plemię Dotnetu nie zawsze było pokojowo nastawione. Wojownicy z poszczególnych wiosek nieraz toczyli ze sobą krwawe boje. Zwyczaje te zanikły wraz z coraz większym ucywilizowaniem społeczności. Jednak nostalgia za starymi czasami sprawiła, że mieszkańcy Wyspy co jakiś czas organizowali walki pomiędzy sobą. Dla obserwujących to pracowników Ady i Serweryna wyglądało to jak łagodny turniej w Mortal Kombat.

Na polu bitwy w losowych miejscach ustawiali się żądni wrażeń uczestnicy z przypisanymi od 0 do n-1 numerami. Następnie toczyli określoną liczbę pojedynków. W jednym momencie odbywa się tylko jedna walka. W pierwszej kolejności w walce biorą udział dwie osoby, które stoją najbliżej siebie. Zwycięża ta z nich, która ma większą siłę. Zwyciężony wojownik znika z pola bitwy. Zwycięzca nie zmienia swojego początkowego położenia na polu bitwy.

Zakłada się, że w przypadku remisu zwycięża ten wojownik, którego numer jest mniejszy. Jeśli w tej samej odległości znajduje się więcej par wojowników, w pierwszej kolejności rozstrzygana jest walka wojownika o najniższym numerze. Jeśli wojownik ten z racji tej samej odległości może walczyć z kilkoma żołnierzami, to walkę zaczyna z tym o najniższym numerze.

Walki trwają dopóki nie polegnie określona liczba uczestników. Na podstawie rozmieszczenia uczestników oceń kolejność opuszczania pola bitwy.

### Wejście:

Na wejściu program w pierwszej linii otrzyma liczbę dodatnią ***n*** i ***t***, oznaczające liczbę wojowników na polu bitwy oraz liczbę oczekiwanych walk, a w kolejnych ***n*** liniach znajdą się 3 liczby naturalne ***x***, ***y*** oraz ***w***, opisującego kolejnych wojowników, gdzie ***x*** i ***y*** to współrzędne wojownika na polu bitwy, a ***w*** to jego moc.

***2 ≤ n ≤ 10000***

### Wyjście:

Na wyjściu program ma wypisać współrzędne poległych w bitwie wojowników w kolejności ich "umierania".

### Przykład:

Wejście:

```
4 2
1 2 4
3 7 3
2 4 1
5 1 6
```

Wyjście:

```
2 4
1 2
```

***Uwaga! Program ma w swoim rozwiązaniu używać metody "dziel i zwyciężaj" zaimplementowanej ze złożonością O(nlogn).***

### [Rozwiązanie](https://github.com/tukarp/Algorithms-And-Data-Structures/blob/main/Algorithms%20And%20Data%20Structures%20I/Zadanie%206%20-%20Turniej.cpp)

## Zadanie 7 - Premia lub hańba

### Treść Zadania

Grupa programistów na Wyspie co chwilę musiała zdawać raporty z wydajności swoich teamów deweloperskich. Wielki Product Owner całego przedsięwzięcia cyfryzacji Wyspy, czyli Sołtys, każdego dnia prosił któryś z zespołów o informację ile historyjek udało się im ostatnio "dowieźć". Jego plan zakładał, że będzie sprawdzał wydajność ***n*** zespołów w ustalonej kolejności i na podstawie sumy wykonanych zadań ustali, czy pracownikom Ady i Serweryna należy się jakaś premia, czy raczej okrycie hańbą (najwyższy wymiar kary na Wyspie).

Programiści raczej woleli dostawać premię i odkryli, że jeśli tuż przed zdaniem raportu przez ***i-ty*** zespół dokonają jednej zmiany w kolejce raportowania, to Sołtys jakoś tego nie zauważa, nawet jeśli kilkakrotnie dodaje wynik tego samego zespołu. To znaczy, że przed każdym dodaniem do wyniku ***i-tego*** zespołu w kolejce można pozostawić kolejność bez zmian lub zamienić miejscami dwa dowolne zespoły sąsiadujące ze sobą. Programiści zauważyli, że w ten sposób mogą zmaksymalizować swoją końcową sumę i zwiększyć szansę na dostanie premii.

### Wejście:

W pierwszej linii wejścia znajduje się liczba naturalna ***n*** - liczba zespołów. W kolejnej linii znajduje się ***n*** liczb naturalnych ***a(i)***, które odpowiadają liczbie dowiezionych historyjek przez ***i-ty*** zespół.

***2 ≤ n ≤ 500***

***1 ≤ a(i) ≤ 10^6***

### Wyjście:

Na wyjściu należy wyświetlić maksymalny wynik, jaki mogą uzyskać zespoły programistów na koniec raportowania.

### Przykład:

Wejście:

```
5
3 1 5 4 10
```

Wyjście:

```
38
```

***Uwaga! Zadanie ma zostać rozwiązane przy użyciu programowania dynamicznego ze złożonością O(n3).***

### [Rozwiązanie](https://github.com/tukarp/Algorithms-And-Data-Structures/blob/main/Algorithms%20And%20Data%20Structures%20I/Zadanie%207%20-%20Premia%20lub%20hanba.cpp)

## Zadanie 8 - Polowanie na kraby

### Treść Zadania

Część linii brzegowej Wyspy jest domem dla licznej populacji krabów. Przez większość czasu zwierzęta te są pod ścisłą ochroną, jednak raz w roku myśliwi z okolicznych wiosek urządzają wielkie polowanie. Przed rozpoczęciem, Wielki Łowczy wyznacza kwadratowy obszar polowania, który dzieli na pewną liczbę identycznych działek tak, aby wzdłuż długości boku kwadratu mieściło się tyle działek, ile grup bierze udział w wydarzeniu.

Obszar polowania zorientowany jest względem róży kierunków, tzn. przeciwległe ściany wyznaczają kierunki N-S lub E-W. Myśliwi z każdej wioski rozbijają na jednej z działek swój obóz, z którego wyruszają na poszukiwania zdobyczy - zgodnie z tradycją - wyłącznie w 8 kierunków świata (N, E, S, W, NE, SE, SW, NW).
Na takiej "drodze polowania" nie może znaleźć się żaden obóz konkurencyjnych myśliwych: Wyspiarzom zdarzało się mylić kraby z kończynami śpiących towarzyszy.
Ponadto miejsca na plaży różnią się od siebie. Niektóre potrzebują utwardzenia przed założeniem obozu, inne muszą zostać wyposażone w zapory anty-waleniowe (od roku obowiązuje nowy regulamin Bezpieczeństwa i Higieny Polowania), a jeszcze inne po prostu przynoszą mało zdobyczy.
W tegorocznej edycji najmniej kosztowne rozmieszczenie obozów poławiaczy mieli zapewnić Ada i Serweryn, którym w zamian obiecano odstąpić kilkanaście sztuk do budowy krab-komputera.

### Wejście:

W pierwszej linii wejścia znajduje się liczba ***n***, będąca liczbą obozów, które trzeba rozmieścić na kwadratowym obszarze polowania o boku długości ***n*** działek. Kolejne ***n*** linii stanowią ciągi ***n*** liczb całkowitych nieujemnych ***a(i,j)***, gdzie każda liczba ***a(i,j)*** odpowiada kosztowi budowy obozu na polu o koordynatach ***i***, ***j***.

***4 ≤ n ≤ 30***

***0 ≤ a(i,j) ≤ 100***

### Wyjście:

Ciąg ***n*** liczb, stanowiących numery kolumn, w których umieścimy obozy w kolejnych wierszach w najmniej kosztownym, poprawnym rozmieszczeniu. Wyświetlona odpowiedź musi być najmniejszym rozwiązaniem według porządku leksykograficznego.

### Przykład:

Wejście:

```
5
1 5 10 1 3
3 10 10 10 5
10 1 1 5 5
1 1 1 1 1
15 15 10 15 15
```

Wyjście:

```
3 0 2 4 1
```

### [Rozwiązanie](https://github.com/tukarp/Algorithms-And-Data-Structures/blob/main/Algorithms%20And%20Data%20Structures%20I/Zadanie%208%20-%20Polowanie%20na%20kraby.cpp)

## Zadanie 9 - Rankingowe polowanie

### Treść zadania

Po każdym udanym polowaniu konieczny jest podział łupów oraz liczne przechwałki. Pierwsza z tych rzeczy uregulowana jest na Wyspie w bardzo prosty sposób: każdy zachowuje to co złapał. W przypadku drugiej, zasady są jeszcze prostsze: nie ma zasad. Ta lekkoduszność w połączeniu z wrzącą w żyłach krwią Dotnetu sprawiają, że zakończone polowanie zamienia się sportową galę... często bardzo brutalną. Tym razem Wielki Łowczy nie chciał na to pozwolić. Aby powstrzymać myśliwych od walki o status najlepszego, poprosił Adę i Serweryna o uszeregowanie wszystkich uczestników polowania według ich zdobyczy.

### Wejście

W pierwszej linii wejścia podana jest liczba ***n*** myśliwych, biorących udział w polowaniu. Kolejne ***n*** linii to opisy łowców, składające się z: imienia złożonego z, co najwyżej dwudziestu, małych i wielkich liter alfabetu łacińskiego; zadeklarowanej liczby upolowanych krabów ***k_i*** oraz liczby otrzymanych przez myśliwego pułapek ***p_i***.

***1 ≤ n ≤ 100000***

***0 ≤ k_i ≤ 99***

***1 ≤ pi ≤ 9***

### Wyjście

Na wyjściu należy wypisać posortowaną malejąco względem liczby złapanych krabów listę imion myśliwych. W przypadku takiej samej liczby złapanych krabów, pierwszy jest ten, który użył mniejszej liczby pułapek. Jeśli dwie osoby złapały taką samą liczbę krabów przy pomocy tej samej liczby pułapek, należy zachować kolejność z wejścia.

### Przykład

Wejście

```
6
Albert 5 3
Bartek 10 1
Cezary 3 2
Dominik 4 3
Eustachy 1 2
Franek 3 2
```

***
Wyjście

```
Albert Dominik Cezary Franek Eustachy
```

***Uwaga! Nie można używać bibliotek STL. Program ma być samodzielną implementacją sortowania w czasie liniowym.***

### [Rozwiązanie](https://github.com/tukarp/Algorithms-And-Data-Structures/blob/main/Algorithms%20And%20Data%20Structures%20I/Zadanie%209%20-%20Rankingowe%20polowanie.cpp)

